/******************************************************************************
 * Copyright (C) 2019 Martín E. Zahnd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *****************************************************************************/

/**
 * 
 * @file    test_board.c
 * 
 * @brief   ;
 * 
 * @details CUnit Test Suite
 * 
 * @authors Gino Minnucci                               <gminnucci@itba.edu.ar>
 *          Martín E. Zahnd                                <mzahnd@itba.edu.ar>
 * 
 * @date    09/12/2019, 10:00
 *
 * @copyright GNU General Public License v3
 */

/// @publicsection
// === Libraries and header files ===
#include <stdio.h>
#include <stdlib.h>
#include <CUnit/Basic.h>

// Functions to test
#include "../../src/backend/board/board.h"

// === Constants and Macro definitions ===
/**
 * @def CELL(r,c)
 * @brief Returns the information in the row (r) and column (c) of the board
 */
#define CELL(b,r,c) ( *( (b) + ( ( (r) * BOARD_WIDTH ) + (c) ) ) )

// === Enumerations, structures and typedefs ===

// === Global variables ===

// === Function prototypes for private functions with file level scope ===
// Initializes this test suite
int init_suite (void);

// Cleans suite before exiting
int clean_suite (void);

// Print an empty board.
void test1 (void);

// Perform some basic actions of the piece in the board
void test2 (void);

// Stack up three pieces
void test3 (void);

// Test clearing filled lines
void test4 (void);

// Test end game
void test5 (void);

// Verify if the last row has a fixed piece
static int
pieceInLastRow (grid_t * board);

// Print the board
static void
printBoard (grid_t * board);
// === ROM Constant variables with file level scope ===

// === Static variables and constant variables with file level scope ===
// Board structure to use in the tests
static board_t boardStruct;

// === Global function definitions ===

// Code automatically generated by NetBeans

int
main ()
{
    CU_pSuite pSuite = NULL;

    /* Initialize the CUnit test registry */
    if ( CUE_SUCCESS != CU_initialize_registry() )
        return CU_get_error();

    /* Add a suite to the registry */
    pSuite = CU_add_suite("test_random_gen", init_suite, clean_suite);
    if ( NULL == pSuite )
    {
        CU_cleanup_registry();
        return CU_get_error();
    }

    /* Add the tests to the suite */
    if ( (NULL == CU_add_test(pSuite, "test1: Create an empty board",
                              test1)) ||
         (NULL == CU_add_test(pSuite, "test2: Perform some basic actions of "\
                                        "the piece in the board", test2)) ||
         (NULL == CU_add_test(pSuite, "test3: Stack up three pieces",
                              test3)) ||
         (NULL == CU_add_test(pSuite, "test4: Test clearing filled lines",
                              test4)) ||
         (NULL == CU_add_test(pSuite, "test5: Test end game", test5)) )
    {
        CU_cleanup_registry();
        return CU_get_error();
    }

    /* Run all tests using the CUnit Basic interface */
    CU_basic_set_mode(CU_BRM_VERBOSE);
    CU_basic_run_tests();
    CU_cleanup_registry();
    return CU_get_error();
}

// === Suite definitions ===

/**
 * @brief Initializes this test suite
 * 
 * @return Success: 0
 * @return Fail: Non 0
 */
int
init_suite (void)
{
    board_init(&boardStruct);
    return 0;
}

/*
 * @brief Cleans suite before exiting
 * 
 * @return Success: 0
 * @return Fail: Non 0
 */
int
clean_suite (void)
{
    // If the board wasn't destroyed, do it
    if ( boardStruct.destroy != NULL )
    {
        boardStruct.destroy();
    }
    return 0;
}

// Tests definitions ===

/*
 * @brief Print an empty board.
 * 
 * @return Nothing
 */
void
test1 ()
{
    int i, j;

    grid_t * gboard = NULL;

    gboard = boardStruct.ask.board();

    printBoard(gboard);

    for ( i = 0; i < BOARD_HEIGHT; i++ )
    {
        for ( j = 0; j < BOARD_WIDTH; j++ )
        {
            CU_ASSERT(CELL(gboard, i, j) == CELL_CLEAR)
        }
    }
}

/**
 * @brief Perform some basic actions of the piece in the board
 * 
 * @param None
 * 
 * @return Nothing
 */
void
test2 (void)
{
    // Drop it a few times
    boardStruct.update();
    boardStruct.update();
    boardStruct.update();

    printBoard(NULL);

    // Shift it to the left
    boardStruct.piece.shift(LEFT);
    boardStruct.piece.shift(LEFT);
    boardStruct.piece.shift(LEFT);

    printBoard(NULL);

    // Shift it to the right
    boardStruct.piece.shift(RIGHT);
    boardStruct.piece.shift(RIGHT);

    // Drop it once again
    boardStruct.update();

    printBoard(NULL);

    // Rotate it
    boardStruct.piece.rotate(RIGHT);
    printBoard(NULL);

    // Destroy the board
    boardStruct.destroy();
}

/**
 * @brief Stack up three pieces
 * 
 * @param None
 * 
 * @return Nothing
 */
void
test3 (void)
{
    int i, j;

    // Number of pieces to stack up, number of blocks fixed and blocks moving
    int nPieces = 3, fixed = 0, moving = 0;

    // Board
    grid_t * gboard = NULL;

    board_init(&boardStruct);

    // Drop the first piece to make it fully visible
    for ( i = 0; i < 4; i++ )
    {
        boardStruct.update();
    }

    // Stack up nPieces
    for ( i = 0; i < nPieces * BOARD_HEIGHT; i++ )
    {
        boardStruct.update();
    }

    // Print the results
    printBoard(NULL);

    // Read the board
    gboard = boardStruct.ask.board();

    for ( i = 0; i < BOARD_HEIGHT; i++ )
    {
        for ( j = 0; j < BOARD_WIDTH; j++ )
        {
            // The block has a fixed piece
            (CELL(gboard, i, j) >= CELL_I) ? (fixed++) : 0;

            // The block has a moving piece
            (CELL(gboard, i, j) == CELL_MOVING) ? (moving++) : 0;
        }
    }

    CU_ASSERT(fixed == BLOCKS * nPieces);
    CU_ASSERT(moving == BLOCKS);

    // Destroy the board
    boardStruct.destroy();
}

/**
 * @brief Test clearing filled lines
 * 
 * Create a board with two completely filled lines, one half filled and
 * one half filled but with a piece moving and clear the two fully filled.
 * 
 * @param None
 * 
 * @return Nothing
 */
void
test4 (void)
{
    int i;
    int nfl, flines[BOARD_HEIGHT];
    grid_t * tboard;

    // Create the board and make a piece appear at the top (it should be always
    // there)
    board_init(&boardStruct);
    boardStruct.update();
    boardStruct.update();

    // Get board
    tboard = boardStruct.ask.board();
    if ( tboard == NULL )
    {
        CU_FAIL("Could not get board in tboard.\n");
    }

    /*
     * Last six lines of the board
     * 
     *  0  0  0  0  0  0  0  0  0  0 
     *  0  0  0 -1 -1  0  3  0  0  0 
     *  2  2 -1 -1  3  3  3  0  0  0 
     *  2  1  1  1  1  6  1  1  1  1 
     *  2  0  0  0  6  6  6  0  4  4 
     *  1  1  1  1  1  1  1  1  4  4 
     */
    // Fill the bottom line with to TETROMINO_I, and a TETROMINO_O
    for ( i = 0; i < 2 * BLOCKS; i++ )
    {
        CELL(tboard, BOARD_HEIGHT - 1, i) = CELL_I;
    }

    CELL(tboard, BOARD_HEIGHT - 1, BOARD_WIDTH - 2) = CELL_O;
    CELL(tboard, BOARD_HEIGHT - 2, BOARD_WIDTH - 2) = CELL_O;
    CELL(tboard, BOARD_HEIGHT - 1, BOARD_WIDTH - 1) = CELL_O;
    CELL(tboard, BOARD_HEIGHT - 2, BOARD_WIDTH - 1) = CELL_O;

    // Fill the second to last line again with two TETROMINO_I
    for ( i = BOARD_WIDTH - 1; i > BOARD_WIDTH - 2 - (2 * BLOCKS); i-- )
    {
        CELL(tboard, BOARD_HEIGHT - 3, i) = CELL_I;
    }

    // Add a TETROMINO_T in the next to last line and between the two 
    // TETROMINO_I
    CELL(tboard, BOARD_HEIGHT - 2, BOARD_WIDTH - 4) = CELL_T;
    CELL(tboard, BOARD_HEIGHT - 2, BOARD_WIDTH - 5) = CELL_T;
    CELL(tboard, BOARD_HEIGHT - 2, BOARD_WIDTH - 6) = CELL_T;
    CELL(tboard, BOARD_HEIGHT - 3, BOARD_WIDTH - 5) = CELL_T;

    // Add two TETROMINO_L on top
    CELL(tboard, BOARD_HEIGHT - 4, BOARD_WIDTH - 4) = CELL_L;
    CELL(tboard, BOARD_HEIGHT - 4, BOARD_WIDTH - 5) = CELL_L;
    CELL(tboard, BOARD_HEIGHT - 4, BOARD_WIDTH - 6) = CELL_L;
    CELL(tboard, BOARD_HEIGHT - 5, BOARD_WIDTH - 4) = CELL_L;

    CELL(tboard, BOARD_HEIGHT - 4, BOARD_WIDTH - 1) = CELL_L;
    CELL(tboard, BOARD_HEIGHT - 4, BOARD_WIDTH - 2) = CELL_L;
    CELL(tboard, BOARD_HEIGHT - 4, BOARD_WIDTH - 3) = CELL_L;
    CELL(tboard, BOARD_HEIGHT - 5, BOARD_WIDTH - 1) = CELL_L;

    // Fill the second to last line with a TETROMINO_J
    CELL(tboard, BOARD_HEIGHT - 2, 0) = CELL_J;
    CELL(tboard, BOARD_HEIGHT - 3, 0) = CELL_J;
    CELL(tboard, BOARD_HEIGHT - 4, 0) = CELL_J;
    CELL(tboard, BOARD_HEIGHT - 4, 1) = CELL_J;

    // Finally, add a piece moving which "fills" the third to last line
    CELL(tboard, BOARD_HEIGHT - 4, 2) = CELL_MOVING;
    CELL(tboard, BOARD_HEIGHT - 4, 3) = CELL_MOVING;
    CELL(tboard, BOARD_HEIGHT - 5, 3) = CELL_MOVING;
    CELL(tboard, BOARD_HEIGHT - 5, 4) = CELL_MOVING;

    // Print the current board
    printBoard(tboard);

    // Get lines that should be cleared
    nfl = boardStruct.ask.filledRows(flines);
    CU_ASSERT(nfl == 2);
    CU_ASSERT(flines[1] == BOARD_HEIGHT - 1);
    CU_ASSERT(flines[0] == BOARD_HEIGHT - 3);

    // Clear both of them
    boardStruct.clear.line(flines, 1);
    boardStruct.clear.line(flines, 0);

    // Check the bottom six rows
    /*
     *  0  0  0  0  0  0  0  0  0  0 
     *  0  0  0 -1 -1  0  0  0  0  0 
     *  0  0 -1 -1  0  0  0  0  0  0 
     *  0  0  0  0  0  0  3  0  0  3 
     *  2  2  0  0  3  3  3  3  3  3 
     *  2  0  0  0  6  6  6  0  4  4 
     */
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 1, 0) == 2);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 1, 1) == 0);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 1, 2) == 0);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 1, 3) == 0);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 1, 4) == 6);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 1, 5) == 6);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 1, 6) == 6);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 1, 7) == 0);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 1, 8) == 4);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 1, 9) == 4);

    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 2, 0) == 2);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 2, 1) == 2);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 2, 2) == 0);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 2, 3) == 0);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 2, 4) == 3);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 2, 5) == 3);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 2, 6) == 3);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 2, 7) == 3);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 2, 8) == 3);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 2, 9) == 3);

    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 3, 0) == 0);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 3, 1) == 0);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 3, 2) == 0);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 3, 3) == 0);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 3, 4) == 0);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 3, 5) == 0);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 3, 6) == 3);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 3, 7) == 0);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 3, 8) == 0);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 3, 9) == 3);

    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 4, 0) == 0);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 4, 1) == 0);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 4, 2) == -1);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 4, 3) == -1);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 4, 4) == 0);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 4, 5) == 0);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 4, 6) == 0);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 4, 7) == 0);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 4, 8) == 0);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 4, 9) == 0);

    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 5, 0) == 0);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 5, 1) == 0);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 5, 2) == 0);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 5, 3) == -1);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 5, 4) == -1);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 5, 5) == 0);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 5, 6) == 0);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 5, 7) == 0);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 5, 8) == 0);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 5, 9) == 0);

    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 6, 0) == 0);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 6, 1) == 0);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 6, 2) == 0);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 6, 3) == 0);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 6, 4) == 0);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 6, 5) == 0);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 6, 6) == 0);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 6, 7) == 0);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 6, 8) == 0);
    CU_ASSERT(CELL(tboard, BOARD_HEIGHT - 6, 9) == 0);

    // Print the board
    printBoard(tboard);

    // And destroy it
    boardStruct.destroy();
}

/**
 * @brief Test end game
 * 
 * Stack up enough pieces to perform an end game
 * 
 * @param None
 * 
 * @return Nothing
 */
void
test5 (void)
{
    // Initialize the board
    board_init(&boardStruct);

    // Stack up pieces until the last visible row has a fixed one
    while ( !pieceInLastRow(NULL) )
    {
        boardStruct.update();

        // Game must not end while "still playing"
        (pieceInLastRow(NULL)) ? \
            1 : (CU_ASSERT(boardStruct.ask.endGame() == 0));

    }

    // Update the board twice so any new piece also gets stacked up
    boardStruct.update();
    boardStruct.update();

    // And perform an endGame check
    CU_ASSERT(boardStruct.ask.endGame() == 1);

    // Finally, print the board
    printBoard(NULL);
}
// === Local function definitions ===

/**
 * @brief Verify if the last row has a fixed piece
 * 
 * @param board Board from which to read the last row. If NULL, the board is
 * asked using boardStruct.ask.board();
 * 
 * @return True: Non zero
 * @return False: Zero
 */
static int
pieceInLastRow (grid_t * board)
{
    int i, ans = 0;

    // Get board if necessary
    if ( board == NULL )
    {
        board = boardStruct.ask.board();
    }

    // Read row 0 and set ans to 0 if at least one grid has a fixed block
    for ( i = 0; i < BOARD_WIDTH; i++ )
    {
        (CELL(board, 0, i) > CELL_CLEAR) ? (ans = 1) : 0;
    }

    return ans;
}

/**
 * @brief Print the board
 * 
 * @param board Board to print. If NULL, the board is asked using 
 * boardStruct.ask.board();
 * 
 * @return Nothing
 */
static void
printBoard (grid_t * board)
{
    int i, j;

    // Get board if necessary
    if ( board == NULL )
    {
        board = boardStruct.ask.board();
    }

    // Print board
    for ( i = 0; i < BOARD_HEIGHT; i++ )
    {
        putchar('\n');
        for ( j = 0; j < BOARD_WIDTH; j++ )
        {
            // When the grid has a two digits number, print it without an extra
            // space
            if ( CELL(board, i, j) < CELL_CLEAR || CELL(board, i, j) > 9 )
            {
                printf("%d ", CELL(board, i, j));
            }
            else
            {
                printf(" %d ", CELL(board, i, j));
            }
        }
    }

    putchar('\n');
}
