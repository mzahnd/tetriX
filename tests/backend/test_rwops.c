/******************************************************************************
 * Copyright (C) 2020 Martín E. Zahnd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *****************************************************************************/

/**
 * 
 * @file    test_rwops.c
 * 
 * @brief   ;
 * 
 * @details CUnit Test Suite
 * 
 * @authors Gino Minnucci                               <gminnucci@itba.edu.ar>
 *          Martín E. Zahnd                                <mzahnd@itba.edu.ar>
 * 
 * @date    23/01/2020, 15:00
 *
 * @copyright GNU General Public License v3
 */

/// @publicsection
// === Libraries and header files ===
#include <stdio.h>
#include <stdlib.h>
#include <CUnit/Basic.h>

// Functions to test
#include "../../src/backend/rw/rw_ops.h"

// === Constants and Macro definitions ===

#define OK          1
#define FAIL        -1

// Position of the top score to modify
#define TEST5_POS   2

// === Enumerations, structures and typedefs ===

// === Global variables ===

// === Function prototypes for private functions with file level scope ===
int init_suite (void);
int clean_suite (void);

void test1 (void);
void test2 (void);
void test3 (void);
void test4 (void);
void test5 (void);

static void
test5_cmpdata (const rwScores_t * const tmpStru, int score, char * name);

// === ROM Constant variables with file level scope ===

// === Static variables and constant variables with file level scope ===
static rwScores_t testStruct;

// === Global function definitions ===

// Code automatically generated by NetBeans

int
main ()
{
    CU_pSuite pSuite = NULL;

    /* Initialize the CUnit test registry */
    if ( CUE_SUCCESS != CU_initialize_registry() )
        return CU_get_error();

    /* Add a suite to the registry */
    pSuite = CU_add_suite("test_rwops", init_suite, clean_suite);
    if ( NULL == pSuite )
    {
        CU_cleanup_registry();
        return CU_get_error();
    }

    /* Add the tests to the suite */
    if ( (NULL == CU_add_test(pSuite, "test1", test1)) ||
         (NULL == CU_add_test(pSuite, "test2", test2)) ||
         (NULL == CU_add_test(pSuite, "test3", test3)) ||
         (NULL == CU_add_test(pSuite, "test4", test4)) ||
         (NULL == CU_add_test(pSuite, "test5", test5)) )
    {
        CU_cleanup_registry();
        return CU_get_error();
    }

    /* Run all tests using the CUnit Basic interface */
    CU_basic_set_mode(CU_BRM_VERBOSE);
    CU_basic_run_tests();
    CU_cleanup_registry();
    return CU_get_error();
}

// === Suite definitions ===

int
init_suite (void)
{
    return init_rwOps(&testStruct);
}

int
clean_suite (void)
{
    return 0;
}

// Tests definitions ===

/**
 * @brief Structure is properly initialized
 */
void
test1 ()
{
    // Counter
    int i;

    // Function pointers
    CU_ASSERT_PTR_NOT_NULL(testStruct.add.writeIntoScore);
    CU_ASSERT_PTR_NOT_NULL(testStruct.get.readTopScore);

    // Get substructure
    // Scores are set to 0
    for ( i = 0; i < NTOPSCORE; i++ )
    {
        CU_ASSERT_EQUAL(testStruct.get._scores[i], 0);
    }

    // Names are empty
    for ( i = 0; i < NTOPSCORE; i++ )
    {
        CU_ASSERT_STRING_EQUAL(testStruct.get._names[i], "");
    }

    // Add substructure
    CU_ASSERT_EQUAL(testStruct.add.score, 0);
    CU_ASSERT_STRING_EQUAL(testStruct.add.name, "");
}

/**
 * @brief Read top score
 * 
 * @warning Check that the top scores file DOES NOT EXISTS before running this
 * test, as part of it is trying to read an non-existing file and creating it
 * as consecuence of that.
 * 
 * @note An message in stderr saying "Opening error. Creating file." is normal
 * and expected to appear.
 */
void
test2 ()
{
    // Counter
    int i;

    // Top dummy score. Copied from DUMMYTOPSCORE macro in rw_ops.c
    int topscore = 100000 * NTOPSCORE;

    // Read the top score file (which does not exists)
    CU_ASSERT_EQUAL(testStruct.get.readTopScore(&testStruct), EXIT_SUCCESS);

    // Check values
    for ( i = 0; i < NTOPSCORE; i++ )
    {
        CU_ASSERT_EQUAL(testStruct.get._scores[i], topscore);
        topscore /= 2;
    }

    // Check names
    for ( i = 0; i < NTOPSCORE; i++ )
    {
        // Expected string copied from DUMMYNAME macro in rw_ops.c
        CU_ASSERT_STRING_EQUAL(testStruct.get._names[i], "---");
    }
}

/**
 * @brief Try writting a new score that is lower than the lowest in the top
 */
void
test3 ()
{
    // Counter
    int i;

    // Score lower than the lowest in the top
    int lowerScore = testStruct.get._scores[NTOPSCORE - 1] - 1;
    // Dummy name different than "---"
    char * falseName = "ABC";

    strncpy(testStruct.add.name, falseName, NAMESIZE - 1);
    testStruct.add.score = lowerScore;

    CU_ASSERT_EQUAL(testStruct.add.writeIntoScore(&testStruct), EXIT_SUCCESS);

    // Check values
    for ( i = 0; i < NTOPSCORE; i++ )
    {
        CU_ASSERT_NOT_EQUAL(testStruct.get._scores[i], lowerScore);
    }

    // Check names
    for ( i = 0; i < NTOPSCORE; i++ )
    {
        // Expected string copied from DUMMYNAME macro in rw_ops.c
        CU_ASSERT_STRING_NOT_EQUAL(testStruct.get._names[i], falseName);
    }
}

/**
 * @brief Try writting a new score with a name longer than NAMESIZE
 * 
 * Test success is when ABC is written as the name instead of ABCD
 */
void
test4 ()
{
    // Counter
    int i;

    // Score lower than the lowest in the top
    int score = testStruct.get._scores[NTOPSCORE - 1] + 1;
    // Dummy name different than "---"
    char * badName = "ABCD";
    char * okName = "ABC";

    // Bad copy the string
    strncpy(testStruct.add.name, badName, NAMESIZE);
    // "Player" score
    testStruct.add.score = score;

    CU_ASSERT_EQUAL(testStruct.add.writeIntoScore(&testStruct), EXIT_SUCCESS);

    // Check values
    for ( i = 0; i < NTOPSCORE - 1; i++ )
    {
        CU_ASSERT_NOT_EQUAL(testStruct.get._scores[i], score);
    }

    CU_ASSERT_EQUAL(testStruct.get._scores[i], score);

    // Check names
    for ( i = 0; i < NTOPSCORE; i++ )
    {
        // Expected string copied from DUMMYNAME macro in rw_ops.c
        CU_ASSERT_STRING_NOT_EQUAL(testStruct.get._names[i], badName);
    }

    CU_ASSERT_STRING_EQUAL(testStruct.get._names[--i ], okName);
}

/**
 * @brief Add a valid new score in the third position of the top
 */
void
test5 ()
{
    // Copy of the original structure to compare the new and old data
    rwScores_t tmpStru;

    // Data to add
    int score = testStruct.get._scores[TEST5_POS] + 2;
    char * name = "MEZ";

    // Read file
    CU_ASSERT_EQUAL(testStruct.get.readTopScore(&testStruct), EXIT_SUCCESS);

    // Copy structures
    memcpy(&tmpStru, &testStruct, sizeof (rwScores_t));

    // Set new name
    strncpy(testStruct.add.name, name, NAMESIZE - 1);
    // New score
    testStruct.add.score = score;

    // Write in the file
    CU_ASSERT_EQUAL(testStruct.add.writeIntoScore(&testStruct), EXIT_SUCCESS);

    // Compare data as it is
    test5_cmpdata(&tmpStru, score, name);

    // Read the file again and compare data
    CU_ASSERT_EQUAL(testStruct.get.readTopScore(&testStruct), EXIT_SUCCESS);
    test5_cmpdata(&tmpStru, score, name);
}
// === Local function definitions ===

/**
 * @brief Compare data in structures used in test5
 * 
 * @param tmpStru Structure with the original data
 * @param score New score
 * @param name New name
 * @return Nothing
 */
static void
test5_cmpdata (const rwScores_t * const tmpStru, int score, char * name)
{
    // Counter
    int i;

    for ( i = 0; i < NTOPSCORE; i++ )
    {
        // Items before the new one
        if ( i < TEST5_POS )
        {
            CU_ASSERT_EQUAL(testStruct.get._scores[i],
                            tmpStru -> get._scores[i]);

            CU_ASSERT_STRING_EQUAL(testStruct.get._names[i],
                                   tmpStru -> get._names[i]);
        }

            // New item
        else if ( i == TEST5_POS )
        {
            CU_ASSERT_EQUAL(testStruct.get._scores[i], score);
            CU_ASSERT_STRING_EQUAL(testStruct.get._names[i], name);
        }

            // Items after the new one
        else
        {
            CU_ASSERT_EQUAL(testStruct.get._scores[i],
                            tmpStru -> get._scores[i - 1]);

            CU_ASSERT_STRING_EQUAL(testStruct.get._names[i],
                                   tmpStru -> get._names[i - 1]);
        }
    }
}
